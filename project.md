# Vue

## 生命周期函数 *
```
# beforeCreate 
  创建前  此时的el<dom>还未初始化 data函数也还未初始化 
  场景1. 可以在这加个loading事件，在加载实例时触发
# created
  创建后  此时的el<dom>还未初始化 data里的数据已挂载可以读取 可以做网络请求  如果非要想，可以通过vm.$nextTick来访问Dom
  场景1.  初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
# beforeMount
  载入前  此时的el<dom>已初始化完成 data里的数据已挂载可以读取 但还是挂载之前为虚拟的dom节点
# mounted
  载入后  此时的el<dom>已初始化完成 可以操作Dom data里的数据已挂载可以读取
  场景1. 挂载元素，获取到DOM节点
# beforeUpdate 更新前
# updated      更新后
  场景1. 如果对数据统一处理，在这里写上相应函数
# beforeDestroy销毁前 清除定时器
# destroyed    销毁后 组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

```
## vue里的data为什么是个函数? *

> 如果是一个object对象那么每生成有个组件都是用的同一个data内存,由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改. 要是一个function函数由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。

## vue中的v-if和v-show的区别? *

> v-if是条件渲染会对标签进行适当的创建和销毁,v-show只是修改css属性隐藏和展示

## computed和watch的区别? *

```
# computed 计算属性 *
  支持缓存，只有依赖数据发生改变，才会重新进行计算
  不支持异步，当computed内有异步操作时无效，无法监听数据的变化
  如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

# watch 侦听器 *
  不支持缓存，数据变，直接会触发相应的操作；
  watch支持异步；
  监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值
  有两个值: immediate 组件加载立即触发回调函数执行
             deep      deep的意思就是深入观察，监听器会一层层的往下遍历
```

## vue-loader是什么？使用它的用途有哪些？
   vue文件的一个加载器，跟template/js/style转换成js模块。

## $nextTick是什么？
   vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。
>  nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM

## v-for key的作用 *
   key的作用就相当于唯一的标识符,key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法

## Vue的双向数据绑定原理是什么？ *
   vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
   MVVM作为数据绑定的入口，整合<Observer>、<Compile>和<Watcher>三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

## 组件传值 *

```
# 父传子
  通过props传递 

# 子传父
  在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值

# slot 插槽
  

```

## prop 验证，和默认值
   我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告
    props: {
       visible: {
          default: true, 值是否为空
          type: Boolean, 类型
          required: true
       },
    },

## 请说下封装 vue 组件的过程
   首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。
   然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。

## Vue.js的template编译 *
   template -> AST树 -> render函数 -> VNode（Vue的虚拟DOM节点） -> 真实Dom

## scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？ *
   scss 预处理语言
   第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）
   第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss
   第三步：还是在同一个文件，配置一个module属性
   第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”
   特性主要有:
       可以用变量，例如（$变量名称=值）可以用混合器，例如（）可以嵌套

## vue如何监听对象或者数组某个属性的变化 *
   this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)
   调用以下几个数组的方法
     splice()、 push()、pop()、shift()、unshift()、sort()、reverse()

## 常用的事件修饰符 *
   .stop:阻止冒泡
   .prevent:阻止默认行为
   .self:仅绑定元素自身触发
   .once: 2.1.4 新增,只触发一次passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和
   .prevent 一起使用
   .sync 修饰符

## vue如何获取dom *
   先给标签设置一个ref值，再通过this.$refs.domName获取
   <div ref="test"></div>
   const dom = this.$refs.test

## assets和static的区别
   项目静态文件
   assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。
   static 是不会被打包

## slot插槽
   很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。

## vue初始化页面闪动问题
   使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。
   首先：在css里加上以下代码
     [v-cloak] {
       display: none;
     }
  如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: 'block'}"

## 知道什么是vuex吗？
   在SPA单页面组件的开发中 Vue的vuex和React的Redux 都统称为同一状态管理，个人的理解是全局状态管理更合适；简单的理解就是你在state中定义了一个数据之后，你可以在所在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。

```
# 核心概念1: State
  state就是Vuex中的公共的状态, 我是将state看作是所有组件的data, 用于保存所有组件的公共数据.

# 核心概念2: Getters
  我将getters属性理解为所有组件的computed属性, 也就是计算属性. vuex的官方文档也是说到可以将getter理解为store的计算属性, getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。

# 核心概念3: Mutations
  我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫type, 第一个参数是state, 第二参数是payload, 也就是自定义的参数.

# 核心概念4: Actions
  actions 类似于 mutations，不同在于：actions提交的是mutations而不是直接变更状态actions中可以包含异步操作, mutations中绝对不允许出现异步actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象

```

## v-model是如何实现双向绑定的？ *
   v-model是用来在表单控件或者组件上创建双向绑定的
   他的本质是v-bind和v-on的语法糖
   在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件

## vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？ *

```
# hash 模式：
  #后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面
  通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。

# history 模式：
  history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作

# 区别
  1. url 展示上，hash 模式有“#”，history 模式没有
  2. 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由
  3. 兼容性，hash 可以支持低版本浏览器和 IE。

```
## 路由懒加载是什么意思？如何实现路由懒加载？
   路由懒加载的含义：把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件

## Vue-router 导航守卫有哪些? *
   1. 全局前置/钩子：beforeEach、beforeResolve、afterEach
   2. 路由独享的守卫：beforeEnter
   3. 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

## vue2.0中的$router 和 $route的区别 *
   1.router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。
   举例：history
   对象$router.push({path:'home'});本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录方法：
     $router.replace({path:'home'});//替换路由，没有历史记录  // 路由跳转
   2.route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等
   我们可以从vue devtools中看到每个路由对象的不同  // 获取路由信息

## Vue模版编译原理知道吗，能简单说一下吗？
   Vue的编译过程就是将template转化为render函数的过程
   首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
   Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。
   编译的最后一步是将优化后的AST树转换为可执行的代码。

## 说说你对keep-alive组件的了解
   keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染

```
# 特征
  一般结合路由和动态组件一起使用，用于缓存组件；
  提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
  对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

```

## 你都做过哪些Vue的性能优化？
   1. 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
   2. v-if和v-for不能连用
   3. 如果需要使用v-for给每项元素绑定事件时使用事件代理
   4. SPA 页面采用keep-alive缓存组件
   5. 在更多的情况下，使用v-if替代v-show
   6. key保证唯一
   7. 使用路由懒加载、异步组件
   8. 防抖、节流
   9. 第三方模块按需导入
   10. 长列表滚动到可视区域动态加载
   11. 图片懒加载
   12. 骨架屏
   13. 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。

## 说说你对 SPA 单页面的理解，它的优缺点分别是什么？
   SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
   
```
# 优点
   用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
   基于上面一点，SPA 相对对服务器压力小；
   前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

# 缺点
  初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
  前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
  SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。


```
## Vue-自定义指令
   1. 比如定义一个全局可用的focus实现input选中，全局的东西如JS中的全局变量，一般不会用。
      Vue.directive("focus",{
         inserted:function(el){
            el.focus()
         }
      })
   2. 定义局部指令，局部指令只在组件内部有效，超出组件范围则无效，类似局部变量的作用。
      Vue.component("my-component",{
         template:"<div v-acion>1111<div>",
         directives:{
            acion:{
               inserted:function(el){
                     console.log("999")
               }
            }
         }
      })

## 网页从输入网址到渲染完成经历了哪些过程？
   1. 输入网址；
   2. 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；
   3. 与web服务器建立TCP连接；
   4. 浏览器向web服务器发送http请求；
   5. web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；
   6. 浏览器下载web服务器返回的数据及解析html源文件；生成DOM树，解析css和js，渲染页面，直至显示完成；

## ajax请求的过程
   1. 创建XMLHttpRequest对象
   2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
   3. 设置响应HTTP请求状态变化的函数.
   4. 发送HTTP请求.
   5. 获取异步调用返回的数据.
   6. 使用JavaScript和DOM实现局部刷新.

## sessionStorage,localStorage,cookie 区别
   1. 都会在浏览器端保存，有大小限制，同源限制
   2. cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器
   3. cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie
   4. 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除
   5. 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享
   6. localStorage 的修改会促发其他文档窗口的 update 事件
   7. cookie 有 secure 属性要求 HTTPS 传输
   8. 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M

## HTTP中Get、Post、Put与Delete的区别
   1-1、POST /url 创建
   2-2、DELETE /url/xxx 删除
   3-3、PUT /url/xxx 更新
   4-4、GET /url/xxx 查看
   1. GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。
   2. 与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。
   3. POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。
   4. DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。

## js操作数组的方法
   1. join()：join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。
   2. push()和pop()：push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。
   3. shift() 和 unshift()：shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。 unshift:将参数添加到原数组开头，并返回数组的长度
   4. sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面
   5. reverse()：反转数组项的顺序。
   6. concat()：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。
   7. slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
   8. splice()：splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。
   9. ndexOf()和 lastIndexOf() （ES5新增）：indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。
   10. forEach() （ES5新增）forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。
   11. map() （ES5新增）map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
   12. filter() （ES5新增）filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
   13. every() （ES5新增）every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
   14. some() （ES5新增）some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。
   15. reduce()，reduceRight()reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。

## GET和POST的区别

```
# 区别一
  GET重点从服务器上获取资源,POST重点向服务器发送数据.
# 区别二
  get传输数据是通过URL请求，置于URL后，并用”?”连接，多个请求数据间用”&”连接.post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
# 区别三
  Get传输的数据量小，因为受URL长度限制，但效率较高；
  Post可以传输大量数据，所以上传文件时只能用Post方式；
# 区别四
  get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；
  post较get安全性较高；
# 区别五
  get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
  post支持标准字符集，可以正确传递中文字符。

```

## 如何优化SPA应用的首屏加载速度慢的问题？
   1. 将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；
   2. 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；
   3. 加一个首屏 loading 图，提升用户体验


## 浏览器
   1. 构建请求
      输入网址,判断用户输入的是query或URL,如果是 URL，把 URL 转发给网络线程，网络线程会构建请求行信息，构建好之后，浏览器就准备发起网络请求。
   2. 查找强缓存
      浏览器在发送真正的网络请求之前，会检查浏览器的强缓存，如果命中，直接返回对应资源的副本，否则接着下一步
      2.1 什么是强缓存
          浏览的缓存策略分为强缓存和协商缓存，他们之间的根本区别是是否需要发请求。
          强缓存
            简单来说，强缓存就是你的本地文件（保存在硬盘或者内存中），你可以立马访问到；
          协商缓存
            协商缓存是需要发请求给服务器，问问资源是否有更新，如果没有更新就访问本地缓存；如果更新，服务器会返回更新后的资源文件。
      2.2 强缓存的实现
          在 HTTP/1.0 时代，强缓存是通过 HTTP 响应头中 **Expires** 字段实现的，Expires 的意思是过期，所以这个字段的内容就是一个绝对的失效时间，例如 Expires:Wed, 05 Apr 2020 00:55:35 GMT。浏览器通过这个失效时间和用户的本地时间相比较来判定是否读取缓存中的资源副本，这就带来一个很明显的问题，用户可以自己修改本地时间，使缓存失效。

          所以 HTTP/1.1 中新加入了 **Cache-Control** 字段来解决这个问题，通过设置 cache-control: max-age=XXX ，可以实现缓存在 XXX 秒后过期（相对时间），这样就规避了用户可以自己篡改本地时间使缓存失效的问题。

          在 cache-control 和 Expires 同时存在时，以 cache-control 优先
   
   3. DNS解析
      送真正网络请求首先需要进行 DNS 解析，目的就是找到 URL 对应的服务器 IP 地址。关于 DNS 解析的过程，我简单介绍一下，大致是先查找本地 DNS 缓存，找不到就问本地 DNS 服务器，再依次问根域 DNS 服务器，一级域名服务器，二级域名服务器，最后把找到的 IP 地址层层传递回来。这里再放一张图帮助大家更直观地理解。
   4. 建立TCP连接
      知道服务器的 IP 地址后，就可以跟服务器正式建立连接了，连接的方式分为两种，可靠的 TCP 和不可靠的 UDP，HTTP 协议是基于 TCP 的，所以需要跟服务器建立 TCP 连接。怎么建立呢？通过三次握手。三次握手的流程如下图所示。
   5. 发送请求，收到响应

## em rem px的区别
   1. px是固定的像素，一旦设置了就无法因为适应页面大小而改变。
   2. em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局
   3. 对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。
   4. rem中的r意思是root（根源），这也就不难理解了。

## 闭包

```
  # 闭包的概念
     1. 闭包可以在函数的外部访问到函数内部的局部变量。
     2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。

  # 闭包的用途
     1. 可以读取函数内部的变量
     2. 变量的值始终保持在内存中
   
  # 使用闭包的注意点
     1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
     2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
```
## 什么是 SPA 单页面，它的优缺点分别是什么?
   1. SPA（ single-page application ）即一个web项目就只有一个页面（即一个HTML文件,HTML 内容的变换是利用路由机制实现的。
   2. 仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

```
  # 优点
    1. 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
    2. 基于上面一点，SPA 相对对服务器压力小；
    3. 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

  # 缺点
    1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
    2. 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
    3. SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

```

## 第一次页面加载会触发哪几个钩子?
   第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子